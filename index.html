<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.23.0/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>
    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        backgroundColor: '#ececec',
        scene: {
            preload: preload,
            create: create
        }
    };

    var game = new Phaser.Game(config);
    var cells = [];
    var numRows = 9;
    var numCols = 9;
    var numMines = 10;
    var cellValues = [];
    var numFlags = 0;
    var gameLost = false;

    var smiley;
    var mineSign;
    var mineTens;
    var mineOnes;
    var timerHundreds;
    var timerTens;
    var timerOnes;
    var elapsedSeconds = 0;

    var gridTopLeftX = 4;
    var gridTopLeftY = 48;

    function preload ()
    {
        this.load.setBaseURL('https://raw.githubusercontent.com');
        this.load.atlas('atlas',
                        'karstendick/minej/master/assets/minesweeper-atlas.png',
                        'karstendick/minej/master/assets/minesweeper-atlas.json')
    }

    function cellPointerDown(pointer)
    {
        if (pointer.leftButtonDown() && pointer.rightButtonDown())
        {
            var neighbors = getNeighbors(this);
            neighbors.push(this);
            for (let cell of neighbors)
            {
                if (!cell.getData("isRevealed") && !cell.getData("isFlagged"))
                {
                    cell.setFrame('cell-empty');
                    cell.setData("isDepressed", true);
                }
            }

        } else if (pointer.leftButtonDown())
        {
            if (this.getData("isFlagged") || this.getData("isRevealed"))
                return;
            console.log("pointerdown event at (", this.getData('row'), ", ", this.getData('col'), ")");
            this.setFrame('cell-empty');
            this.setData("isDepressed", true)
        }
    }

    function getDepressedCells()
    {
        var depressedCells = [];
        for(var r = 0; r < numRows; ++r)
        {
            for(var c = 0; c < numCols; ++c)
            {
                var cell = cells[r][c];
                if (cell.getData("isDepressed") && !cell.getData("isRevealed"))
                    depressedCells.push(cell);
            }
        }
        return depressedCells;
    }

    function cellPointerOut(pointer)
    {
        console.log("pointerout event at (", this.getData('row'), ", ", this.getData('col'), ")");
        depressedCells = getDepressedCells();
        for (const cell of depressedCells)
        {
            cell.setFrame('cell-raised')
            cell.setData("isDepressed", false)
        }
    }

    function cellPointerOver(pointer)
    {
        console.log("pointerover event at (", this.getData('row'), ", ", this.getData('col'), ")");
        if (pointer.leftButtonDown() && !pointer.rightButtonDown())
        {
            if (!this.getData("isRevealed") && !this.getData("isFlagged"))
            {
                console.log("pointerover event at (", this.getData('row'), ", ", this.getData('col'), ")");
                this.setData("isDepressed", true);
                this.setFrame('cell-empty');
            }
        } else if (pointer.leftButtonDown() && pointer.rightButtonDown())
        {
            var neighbors = getNeighbors(this);
            neighbors.push(this);
            for (let cell of neighbors)
            {
                if (!cell.getData("isRevealed") && !cell.getData("isFlagged"))
                {
                    cell.setFrame('cell-empty');
                    cell.setData("isDepressed", true);
                }
            }
        }
    }

    function isGameWon()
    {
        if (gameLost)
            return false;
        for(var r = 0; r < numRows; ++r)
        {
            for(var c = 0; c < numCols; ++c)
            {
                var cell = cells[r][c];
                if (!cell.getData("isMine") && !cell.getData("isRevealed"))
                    return false;
            }
        }
        return true;
    }

    function updateGameWon()
    {
        smiley.setFrame('smile-sunglasses');
        updateGameEnd();
    }
    function updateGameLost()
    {
        smiley.setFrame('smile-dead');
        updateGameEnd();
    }
    function updateGameEnd()
    {
        timerEvent.remove();
        for(var r = 0; r < numRows; ++r)
        {
            for(var c = 0; c < numCols; ++c)
            {
                var cell = cells[r][c];
                cell.disableInteractive();
            }
        }
    }

    function cellPointerUp(pointer)
    {
        if ((pointer.leftButtonReleased() && pointer.rightButtonDown())
            || (pointer.leftButtonDown() && pointer.rightButtonReleased()))
        {
            if (this.getData("isFlagged") || !this.getData("isRevealed"))
                return;
            // chording
            var neighbors = getNeighbors(this);
            var numFlaggedNeighbors = neighbors.filter(function(neighbor) {
                    return neighbor.getData('isFlagged');
            }).length;
            if (this.getData("numNeighbors") !== numFlaggedNeighbors)
                return;

            revealNeighbors(this);

            if(isGameWon())
                updateGameWon();
            else if (gameLost)
                updateGameLost();
        } else if (pointer.leftButtonReleased())
        {
            if (this.getData("isRevealed") || this.getData("isFlagged"))
                return;

            console.log("pointerup event at (", this.getData('row'), ", ", this.getData('col'), ")");
            revealCell(this);
            if (this.getData('numNeighbors') == 0 && !gameLost)
            {
                revealNeighbors(this);
            }
            // TODO: Check to see if you won/lost
            // TODO: game over! Reveal board, stop timer, deactivate all cells, etc.
            if(isGameWon())
                updateGameWon();
            else if (gameLost)
                updateGameLost();
        } else if (pointer.rightButtonReleased())
        {
            if(this.getData("isRevealed"))
                return;
            if(this.getData("isFlagged"))
            {
                this.setFrame('cell-raised')
                this.setData("isFlagged", false)
                numFlags--;
            } else
            {
                this.setFrame('cell-flagged')
                this.setData("isFlagged", true)
                numFlags++;
            }
            updateFlagDisplay(numFlags);
        }
    }

    function updateFlagDisplay(numFlags)
    {
        displayNum = Phaser.Math.Clamp(numMines - numFlags, -99, 99);
        if (displayNum < 0)
            mineSign.setFrame('timer-hyphen');
        else
            mineSign.setFrame('timer0');
        displayStr = Math.abs(displayNum).toString();
        if (displayStr.length == 1)
            displayStr = '0' + displayStr;

        mineTens.setFrame('timer' + displayStr[0]);
        mineOnes.setFrame('timer' + displayStr[1]);
    }

    function revealCell(cell)
    {
        cell.setData("isRevealed", true);
        if (cell.getData('isMine'))
        {
            cell.setFrame('cell-detonated-bomb');
            gameLost = true;
            return;
        }
        numNeighbors = cell.getData("numNeighbors");
        if (numNeighbors == 0)
            cell.setFrame('cell-empty');
        else
            cell.setFrame('cell' + cell.getData('numNeighbors'));
    }

    function revealNeighbors(cell)
    {
        revealCell(cell);
        var neighbors = getNeighbors(cell);
        neighbors = neighbors.filter(function(neighbor) {
            return !neighbor.getData("isRevealed") && !neighbor.getData("isFlagged");
        });
        for (var i = 0; i < neighbors.length; ++i)
        {
            revealCell(neighbors[i]);
        }
        for (var i = 0; i < neighbors.length; ++i)
        {
            if ((neighbors[i].getData("numNeighbors") == 0))
                revealNeighbors(neighbors[i]);
        }
    }

    function getCell(row, col)
    {
        if ((0 <= row) && (row < numRows) && (0 <= col) && (col < numCols))
        {
            return cells[row][col];
        }
        return undefined;
    }

    function getNeighbors(cell)
    {
        var row = cell.getData("row");
        var col = cell.getData("col");
        neighbors = [
            getCell(row-1, col),
            getCell(row-1, col+1),
            getCell(row, col+1),
            getCell(row+1, col+1),
            getCell(row+1, col),
            getCell(row+1, col-1),
            getCell(row, col-1),
            getCell(row-1, col-1)
        ];
        neighbors = neighbors.filter(function(neighbor) {
            return neighbor !== undefined;
        });
        return neighbors;
    }

    function timerTick()
    {
        elapsedSeconds = Phaser.Math.Clamp(elapsedSeconds + 1, 0, 999);
        displaySeconds = elapsedSeconds.toString();
        if (displaySeconds.length == 1)
            displaySeconds = '00' + displaySeconds;
        else if (displaySeconds.length == 2)
            displaySeconds = '0' + displaySeconds;

        timerHundreds.setFrame('timer' + displaySeconds[0]);
        timerTens.setFrame('timer' + displaySeconds[1]);
        timerOnes.setFrame('timer' + displaySeconds[2]);
    }

    function create ()
    {
        this.input.mouse.disableContextMenu();

        smiley = this.add.image(gridTopLeftX + (numCols * 16)/2 - 12, gridTopLeftY - 37, 'atlas', 'smile-raised').setOrigin(0);
        smiley.setInteractive();

        mineSign = this.add.image(gridTopLeftX, gridTopLeftY - 36, 'atlas', 'timer0').setOrigin(0);
        mineTens = this.add.image(gridTopLeftX + 13, gridTopLeftY - 36, 'atlas', 'timer0').setOrigin(0);
        mineOnes = this.add.image(gridTopLeftX + 13*2, gridTopLeftY - 36, 'atlas', 'timer0').setOrigin(0);
        updateFlagDisplay(numFlags);

        timerHundreds = this.add.image(gridTopLeftX + (numCols * 16) - 13*3, gridTopLeftY - 36, 'atlas', 'timer0').setOrigin(0);
        timerTens = this.add.image(gridTopLeftX + (numCols * 16) - 13*2, gridTopLeftY - 36, 'atlas', 'timer0').setOrigin(0);
        timerOnes = this.add.image(gridTopLeftX + (numCols * 16) - 13, gridTopLeftY - 36, 'atlas', 'timer0').setOrigin(0);

        timerEvent = this.time.addEvent({delay: 1000, callback: timerTick, repeat: 1000}); // TODO: start paused and unpause on first click

        game.events.on('blur', function() { timerEvent.paused = true; });
        game.events.on('focus', function() { timerEvent.paused = false; });
        // TODO: move this to when the first cell is revealed
        // to ensure that that cell is not a mine
        cellValues = new Array(numRows * numCols);
        cellValues.fill(false);
        cellValues.fill(true, 0, numMines);
        Phaser.Utils.Array.Shuffle(cellValues);

        for(var r = 0; r < numRows; ++r)
        {
            cells[r] = [];
            for(var c = 0; c < numCols; ++c)
            {
                var pxx = c * 16 + gridTopLeftX;
                var pxy = r * 16 + gridTopLeftY;
                var cell = this.add.image(pxx, pxy, 'atlas', 'cell-raised').setOrigin(0);

                cell.setData('row', r);
                cell.setData('col', c);
                cell.setData('isMine', cellValues[r * numRows + c]);
                cell.setData('isFlagged', false);
                cell.setData('isRevealed', false);
                cell.setData('isDepressed', false);

                cell.setInteractive();
                cell.on('pointerdown', cellPointerDown);
                cell.on('pointerout', cellPointerOut);
                cell.on('pointerup', cellPointerUp);
                cell.on('pointerover', cellPointerOver);

                cells[r][c] = cell;
            }
        }
        for(var r = 0; r < numRows; ++r)
        {
            for(var c = 0; c < numCols; ++c)
            {
                neighbors = getNeighbors(cells[r][c]);
                numNeighbors = neighbors.filter(function(neighbor) {
                    return neighbor.getData('isMine');
                }).length;
                cells[r][c].setData('numNeighbors', numNeighbors);
            }
        }
    }

    </script>

</body>
</html>